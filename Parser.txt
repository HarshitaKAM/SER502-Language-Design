Grammar’s Parser:-

program(parsetree(X))--> [start], k(X),[end].

k(block(X,Y))-->[[],d(X),[.],sl(Y),[]].
k(block(X))-->[[],sl(X),[]].

d(dec(X,Y,Z))-->dt(X),sl(Y),[.],d(Z).
d(dec(X,Y))-->dt(X),sl(Y),[.].

dt(dtype(X))-->int(X).
dt(dtype(X))-->bool(X).

sl(slist(X,Y))-->s(X),[.],sl(Y).
sl(slist(X))-->s(X),[.].
sl(slist(X))-->k(X).

s(stmt(X))--> a(X).
s(stmt(X))-->if(X).
s(stmt(X))-->w(X).

a(assign(X,Y))-->i(X),[is],e(Y).

if(ifstate(X,Y))-->[if],[(],b(X),[)],k(Y),[else],k(Y).

w(while(X,Y))-->[while],[(],b(X),[)],k(Y).

b(boolexp(t))—>[t].
b(boolexp(f))—>[f].
b(boolexp(X,Y))-->e(X),[=:],e(Y).
b(boolexp(X))->[!!],e(X).
b(boolexp(X,Y))-->e(X),[<<],e(Y).
b(boolexp(X,Y))-->e(X),[>>],e(Y).

e(arithexp(X,Y))-->ex(X),[+],e(Y).
e(arithexp(X,Y))-->ex(X),[-],e(Y).
e(arithexp(X))-->ex(X).

ex(exp(X,Y))-->i(X),[*],ex(Y).
ex(exp(X,Y))-->n(X),[*],ex(Y).
ex(exp(X,Y))-->i(X),[/],ex(Y).
ex(exp(X,Y))-->n(X),[/],ex(Y).
ex(exp(X))-->i(X).
ex(exp(X))-->n(X).

i(iden(X,Y))-->l(X),i(Y).
i(iden(X))-->l(X).

n(num(X,Y))-->dg(X),n(Y).
n(num(X))-->dg(X).

bool(boolean(true))-->[true].
bool(boolean(false))-->[false].

dg(digit(0)) --> [0].
dg(digit(1)) --> [1].
dg(digit(2)) --> [2].
dg(digit(3)) --> [3].
dg(digit(4)) --> [4].
dg(digit(5)) --> [5].
dg(digit(6)) --> [6].
dg(digit(7)) --> [7].
dg(digit(8)) --> [8].
dg(digit(9)) --> [9].

l(letter(a))-->[a].
l(letter(b))-->[b].
l(letter(c))-->[c].
l(letter(d))-->[d].
l(letter(e))-->[e].
l(letter(f))-->[f].
l(letter(g))-->[g].
l(letter(h))-->[h].
l(letter(i))-->[i].
l(letter(j))-->[j].
l(letter(k))-->[k].
l(letter(l))-->[l].
l(letter(m))-->[m].
l(letter(n))-->[n].
l(letter(o))-->[o].
l(letter(p))-->[p].
l(letter(q))-->[q].
l(letter(r))-->[r].
l(letter(s))-->[s].
l(letter(t))-->[t].
l(letter(u))-->[u].
l(letter(v))-->[v].
l(letter(w))-->[w].
l(letter(x))-->[x].
l(letter(y))-->[y].
l(letter(z))-->[z].

Sample input program and list of Tokens:
start
[
x is 2.
]
if(t)[x is 3.] else [x is 4.]end.

L = [start,[,xis,2,.,],if,(,t,),[,x,is,3,.,],else,[,x,is,4,.,],end,.],program(P,L,[]).